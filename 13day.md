## [html] html5中的form怎么关闭自动完成？
有时候我们希望关闭输入框的自动完成功能，例如当用户输入内容的时候，我们希望使用AJAX技术从数据库搜索并列举而不是在用户的历史记录中搜索。
关闭输入框的自动完成功能有3种方法：

1. 在IE的Internet选项菜单里的内容--自动完成里面设置

2. 设置Form的autocomplete为"on"或者"off"来开启或者关闭自动完成功能（关闭整个表单（form）自动提示功能）

3. 设置输入框(input)的autocomplete为"on"或者"off"来开启或者关闭该输入框的自动完成功能（关闭密码域的自动完成）


## [css] ::before和:after中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？

```css
伪类有：:first-child ，:link:，vistited，:hover:，:active , :focus，:lang
```

```css
伪元素有：::first-line，::first-letter，::before，::after （在苏沈小雨编的CSS2.0中文手册中把:first-line，:first-letter列为伪类应该是理解上的错误）
```


在CSS2之前规范不明确的时候，伪元素和伪类都使用单冒号(:)来表示。

```css
比如 :before :after :hover
```

而CSS3规范中的要求使用双冒号(::)表示伪元素，以此来区分伪元素和伪类。

```css
上面的例子用CSS3的规范就应该写成 ::before ::after :hover
```

为了兼容过去的写法，CSS3之前的伪元素仍然可以使用单冒号(:)来表示，浏览器是可以解析的。

```css
比如 :before 和 ::before 都可以被浏览器解析。
```

但是CSS3之后出现的伪元素必须用双冒号表示，不再支持单冒号的形式。

伪类一般反映无法在CSS中轻松或者可靠检测到的某个元素的状态或者属性；
伪元素表示DOM外部的某种文档结构。

目前所有伪元素有(加粗的是CSS3之后出现)：
```css
::after
::before
::first-letter
::first-line


css3之后出现的
::selection
::backdrop
::placeholder
::marker
::spelling-error
::grammar-error
```

## [js] 说说你对javascript的作用域的理解

[JS作用域](https://github.com/creeperyang/blog/issues/16)


## [软技能] http都有哪些状态码？
### 1开头系列 信息响应
> 100 Continue

这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。

### 2开头系列 成功响应
> 200 成功

请求成功。成功的含义取决于HTTP方法：
GET：资源已被提取并在消息正文中传输。
HEAD：实体标头位于消息正文中。
POST：描述动作结果的资源在消息体中传输。
TRACE：消息正文包含服务器收到的请求消息

> 201 Created

该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。

> 202 Accepted

请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。

> 204 No Content

服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息

> 206 Partial Content

服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。

### 3开头系列 重定向 
> 301 Moved Permanently

被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。

> 302 Found

请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

> 303 See Other

对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。

> 304 Not Modified

如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。

> 307 Temporary Redirect

请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

### 4开头系列 客户端响应
> 400 Bad Request

1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
2、请求参数有误。

> 401 Unauthorized

当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。

> 403 Forbidden

服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。

> 404 Not Found

请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。

> 406 Not Acceptable

请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。
### 5开头系列 服务端响应

> 500 Internal Server Error

服务器遇到了不知道如何处理的情况。

> 502 Bad Gateway

此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。

> 503 Service Unavailable

服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。

> 504 Gateway Timeout

当服务器作为网关，不能及时得到响应时返回此错误代码。